# JavaScript. Лучшие практики
## 1. Минимизируйте использование глобальных переменных
Глобальные переменные и функции могут быть перезаписаны другими скриптами.

Хорошо
``` js
let s = () => {
  let r = 5;
  Math.PI*Math.pow(r, 2);
}
````
Плохо
``` js
let r = 5;
let s = () => {
  Math.PI*Math.pow(r, 2);
}
````

## 2. Всегда объявляйте локальные переменные
Как следствие, мы должны всегда объявлять локальные переменные и постоянные с помощью var, let или const. В противном случае переменная будет объявлена как глобальная.

Хорошо
``` js
let x = 1;
````
Плохо
``` js
x = 1;
````

## 3. Объявления сверху
Хорошей практикой является размещение всех объявлений в начале каждого скрипта или функции. Это сделает чище код, предоставит единственное место для поиска локальных переменных, позволит избегать нежелательных глобальных переменных, уменьшит возможность нежелательных повторных объявлений.

Хорошо
``` js
// Объявите в начале
let firstName, lastName, price, discount, fullPrice;

// Используйте после
firstName = "John";
lastName = "Doe";

price = 19.90;
discount = 0.10;

fullPrice = price * 100 / discount;
````

## 4. Инициализация переменных
Хорошей практикой является инициализация переменных при их объявлении. Это сделает код чище, предоставит единственное место для инициализации переменных, позволит избежать неопределенных значений.

Хорошо
``` js
// Объявите и инициализируйте в начале
let firstName = "",
lastName = "",
price = 0,
discount = 0,
fullPrice = 0,
myArray = [],
myObject = {};
````

## 5. Никогда не объявляйте числовые (number), строковые (string) или логические (boolean) объекты
Всегда обрабатывайте числа, строки или логические значения как примитивные значения, а не как объекты. Объявление этих типов как объектов замедляет скорость выполнения и вызывает неприятные побочные эффекты.

Хорошо
``` js
let x = "John";             
let y = "John";
(x === y) // является true
````
Плохо
``` js
let x = "John";             
let y = new String("John");
(x === y) // является false, потому что x является строкой и y является объектом.
````
Плохо
``` js
let x = new String("John");             
let y = new String("John");
(x == y) // является false, потому что вы не можете сравнивать объекты.
````

## 6. Не используйте new Object()
+ Используйте {} вместо new Object()
+ Используйте "" вместо new String()
+ Используйте 0 вместо new Number()
+ Используйте false вместо new Boolean()
+ Используйте [] вместо new Array()
+ Используйте function (){} вместо new Function()

Это сделает ваш код более компактным и читаемым.

Хорошо
``` js
let users = {};                 // new object
let name = "";                  // new primitive string
let id = 0;                     // new primitive number
let isAdmin = false;            // new primitive boolean
let names = [];                 // new array object
let showMessage = function(){}; // new function object
````
Плохо
``` js
let users = new Object();   
let name = new String();           
let id = new Number();              
let isAdmin = new Boolean();        
let names = new Array();           
let showMessage = new Function(); 
````

## 7. Остерегайтесь автоматических преобразований типов
Помните, что числа могут быть случайно преобразованы в строки или NaN. JavaScript слабо типизирован. Переменная может содержать разные типы данных, а переменная может изменять свой тип данных. При выполнении математических операций JavaScript может преобразовывать числа в строки. Например:
``` js
let x = 5 + 7;       // x.valueOf() является 12,  тип x является числом
let x = 5 + "7";     // x.valueOf() является 57,  тип x является строкой
let x = "5" + 7;     // x.valueOf() является 57,  тип x является строкой
let x = 5 - 7;       // x.valueOf() является -2,  тип x является числом
let x = 5 - "7";     // x.valueOf() является -2,  тип x является числом
let x = "5" - 7;     // x.valueOf() является -2,  тип x является числом
let x = 5 - "x";     // x.valueOf() является NaN, тип x является числом
````

Вы можете избежать ошибок, используя приведение типов с помощью унарных операторов "+" и "-":

Хорошо
``` js
// `foo` была объявлена, ей был присвоен `0` и ее тип `number`
let foo = 0;

// Далее в коде вам нужно обновить значение `foo`
// новым значением из input элемента

foo = +document.getElementById("foo-input").value;
//    ^ унарный оператор + приведет правую часть выражения к типу `number`

// typeof foo;
// "number"

if ( foo === 1 ) {

  importantTask();

}

// `importantTask()` будет вызвана
````
Плохо
``` js
let foo = 0;

foo = document.getElementById("foo-input").value;

// Если бы вы проверили тип переменной сейчас `typeof foo`, то получили бы `string`
// Это значит, что если бы вы тестировали `foo` вот так:

if ( foo === 1 ) {

  importantTask();

}

// то `importantTask()` не была вызвана, даже если значение `foo` было бы "1"
````

## 8. Используйте === Сравнение
Оператор сравнения == всегда преобразует (в соответствующие типы) перед сравнением. Оператор === вызывает сравнение значений и типа.

Хорошо
``` js
0 === "";       // false
1 === "1";      // false
1 === true;     // false
````
Плохо
``` js
0 == "";        // true
1 == "1";       // true
1 == true;      // true
````

## 9. Используйте параметры по умолчанию
Если функция вызывается с отсутствующим аргументом, значение отсутствующего аргумента устанавливается в undefined. Неопределенные значения могут нарушить ваш код. Это хорошая привычка назначать значения по умолчанию для аргументов.

Хорошо
``` js
function sum(x = 0, y = 0) {
  return x + y;
}
sum(); //0
````
Плохо
``` js
function sum(x,y) {
  return x + y;
}
sum(); //NaN
````

## 10. Избегайте использования `eval()`
`eval()` - опасная функция, которая выполняет код, проходящий со всеми привилегиями вызывателя. Если вы запускаете eval() со строкой, на которую могут влиять злоумышленники, то вы можете запустить вредоносный код на устройство пользователя с правами вашей веб-страницы. Также eval(),как правило, медленнее альтернатив, так как вызывает интерпретатор JS, тогда как многие другие конструкции оптимизированы современными JS движками.

Хорошо
``` js
let obj = { a: 20, b: 30 };
let propname = getPropName();  // возвращает "a" или "b"
let result = obj[ propname ];  //  obj[ "a" ] то же, что и obj.a 
````
Плохо
``` js
let obj = { a: 20, b: 30 };
let propname = getPropName();  // возвращает "a" или "b"

eval( "let result = obj." + propname );
````